# Lab0.5
为了熟悉使用qemu和gdb进行调试工作,使用gdb调试QEMU模拟的RISC-V计算机加电开始运行到执行应用程序的第一条指令（即跳转到0x80200000）这个阶段的执行过程，说明RISC-V硬件加电后的几条指令在哪里？完成了哪些功能？要求在报告中简要写出练习过程和回答。
王俊杰
# Lab1
##  理解内核启动中的程序入口操作
在 kern/init/entry.S 中，结合操作系统内核启动流程，可以理解以下两条指令：
1. la sp, bootstacktop
la 指令是“加载地址”的缩写（Load Address），用来将某个符号地址加载到寄存器中。在这个指令中：
sp 是栈指针寄存器（Stack Pointer），表示当前栈的顶部。
bootstacktop 是符号，表示内核启动时栈的顶部地址。
这条指令的作用是将内核栈的顶部地址 bootstacktop 加载到栈指针 sp 中。具体步骤是：
内核启动时需要一个专用的栈空间，以便保存函数调用时的局部变量、返回地址等信息。
bootstacktop 定义了内核栈的起始位置，bootstack 是分配的栈空间，大小为 KSTACKSIZE，内存对齐到页大小（PGSHIFT 表示页大小的移位值，通常为 12，即 4KB）。
将栈指针 sp 设置为 bootstacktop 的目的是为内核后续执行准备好栈空间，确保内核代码能够安全地进行栈操作。
2. tail kern_init
tail 指令是一条特殊的跳转指令，它的作用是无条件跳转到目标地址，并且在跳转后不会返回。换句话说，tail 会使得当前的函数（这里是 kern_entry）不会再继续执行后续代码，而是跳转到 kern_init 函数执行，且不会保留返回地址。其效果相当于函数间的“尾调用优化”，减少了栈的开销。
在这个例子中：
tail kern_init 的作用是跳转到 kern_init 函数并开始执行操作系统的初始化过程。
它的目的是启动内核的主要初始化流程，例如设置分页机制、初始化设备、管理内存、加载操作系统内核模块等。
因此，指令 tail kern_init 意味着系统进入内核初始化的关键阶段，并开始执行具体的内核初始化任务。
##  完善中断处理 （需要编程）
+ 代码
szm
## 描述与理解中断流程
wjj
4
## 理解上下文切换机制
sscratch 寄存器通常用于保存陷阱处理过程中需要临时保存的值。csrw sscratch, sp的作用是将当前堆栈指针保存到 sscratch 寄存器，即保存当前的堆栈状态，确保在陷阱处理完后可以恢复到正常的执行流程。

而csrrw s0, sscratch, x0的作用是将 sscratch 寄存器的值保存到 s0，并将 sscratch 设置为0，sscratch为0意味着其正在进行陷阱处理，若在进行陷阱处理时若再出现陷阱，sscratch为0可以避免出现递归陷阱。

sstatus、sepc、sbadaddr、scause这四个寄存器分别保存当前处理器的状态信息、出现陷阱的指令地址、导致陷阱的错误地址、导致陷阱的原因。保存这些信息是为了在处理陷阱时可以确定导致异常的地址，以及确定陷阱的类型。并且保存下来了进入陷阱处理之前的指令地址以及当时的处理器状态，以便在处理后进行恢复。

所以在进行恢复时我们需要sstatus 和 sepc 两个寄存器的值，以确保处理器能够正确返回到异常发生前的状态。而sbadaddr、scause记录的是陷阱的信息，在陷阱处理后便派不上用场，可以不用恢复。

## 完善异常中断
wjj




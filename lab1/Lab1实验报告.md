# Lab0.5
	为了熟悉使用qemu和gdb进行调试工作,使用gdb调试QEMU模拟的RISC-V计算机加电开始运行到执行应用程序的第一条指令（即跳转到0x80200000）这个阶段的执行过程，说明RISC-V硬件加电后的几条指令在哪里？完成了哪些功能？要求在报告中简要写出练习过程和回答。
王俊杰
# Lab1
##  理解内核启动中的程序入口操作
szm

##  完善中断处理 （需要编程）
+ 代码
szm
## 描述与理解中断流程
    描述ucore中处理中断异常的流程（从异常的产生开始），其中mov a0，sp的目的是什么？
    SAVE_ALL中寄寄存器保存在栈中的位置是什么确定的？对于任何中断，__alltraps 中都需要保存所有寄存器吗？请说明理由。
### 描述中断异常的流程
+ CPU会跳到stvec, stvec直接跳到中断处理程序的入口点,对stvec寄存器做初始化。
+ 保存CPU的寄存器（上下文）到内存中（栈上）
+ 进入trap，把中断处理,异常处理的工作分发给了interrupt_handler()，exception_handler(), 这些函数再根据中断或异常的不同类型来处理。
+ 从内存中（栈上）恢复CPU的寄存器
### `move a0, sp`的目的
**`move a0, sp`**这条指令是将栈指针 `sp` 的值移动到寄存器 `a0` 中。这里 `move` 是一个伪指令，本质上是 `addi a0, sp, 0`，即将 `sp` 的值加上 0，并存入 `a0` 中。通过这一步，栈的地址（`sp` 指向的地址）被存放到了 `a0` 寄存器中，作为参数传递给接下来要调用的函数。通过这一步，栈的地址（`sp` 指向的地址）被存放到了 `a0` 寄存器中，作为参数传递给接下来要调用的函数。
`sp` 寄存器保存了当前栈顶的位置。
保存着当前中断发生时的上下文信息，包括寄存器状态和函数调用栈信息。`trap` 函数需要通过传递的 `sp` 值（栈指针）来获取和处理这些上下文信息。当中断发生时，系统的上下文（寄存器、状态等）通常会被保存到栈中。`trap` 函数需要知道这个栈的位置（由 `sp` 指向）来恢复或进一步处理这些上下文数据。
### SAVE_ALL的位置
`csrw sscratch, sp` 先保存原先的栈顶指针到sscratch，然后在`addi sp, sp, -36 * REGBYTES` 的时候让栈顶指针向低地址空间延伸 36个寄存器的空间，可以放下一个trapFrame结构体。
### __alltraps
__alltraps只会保存通用寄存器和部分控制状态寄存器
## 理解上下文切换机制
问题的关键就是解决问题的关键

wjj
问题的关键就是解决问题的
好好学习！！！！

合并还是不合并，这是一个问题

## 完善异常中断
wjj




# Lab0.5
	为了熟悉使用qemu和gdb进行调试工作,使用gdb调试QEMU模拟的RISC-V计算机加电开始运行到执行应用程序的第一条指令（即跳转到0x80200000）这个阶段的执行过程，说明RISC-V硬件加电后的几条指令在哪里？完成了哪些功能？要求在报告中简要写出练习过程和回答。
王俊杰
# Lab1
##  理解内核启动中的程序入口操作
szm

##  完善中断处理 （需要编程）
+ 代码
szm
## 描述与理解中断流程
    描述ucore中处理中断异常的流程（从异常的产生开始），其中mov a0，sp的目的是什么？
    SAVE_ALL中寄寄存器保存在栈中的位置是什么确定的？对于任何中断，__alltraps 中都需要保存所有寄存器吗？请说明理由。
### 描述中断异常的流程
+ CPU会跳到stvec, stvec直接跳到中断处理程序的入口点,对stvec寄存器做初始化。
+ 保存CPU的寄存器（上下文）到内存中（栈上）
+ 进入trap，把中断处理,异常处理的工作分发给了interrupt_handler()，exception_handler(), 这些函数再根据中断或异常的不同类型来处理。
+ 从内存中（栈上）恢复CPU的寄存器
### `move a0, sp`的目的
**`move a0, sp`**这条指令是将栈指针 `sp` 的值移动到寄存器 `a0` 中。这里 `move` 是一个伪指令，本质上是 `addi a0, sp, 0`，即将 `sp` 的值加上 0，并存入 `a0` 中。通过这一步，栈的地址（`sp` 指向的地址）被存放到了 `a0` 寄存器中，作为参数传递给接下来要调用的函数。通过这一步，栈的地址（`sp` 指向的地址）被存放到了 `a0` 寄存器中，作为参数传递给接下来要调用的函数。
`sp` 寄存器保存了当前栈顶的位置。
保存着当前中断发生时的上下文信息，包括寄存器状态和函数调用栈信息。`trap` 函数需要通过传递的 `sp` 值（栈指针）来获取和处理这些上下文信息。当中断发生时，系统的上下文（寄存器、状态等）通常会被保存到栈中。`trap` 函数需要知道这个栈的位置（由 `sp` 指向）来恢复或进一步处理这些上下文数据。
### SAVE_ALL的位置
`csrw sscratch, sp` 先保存原先的栈顶指针到sscratch，然后在`addi sp, sp, -36 * REGBYTES` 的时候让栈顶指针向低地址空间延伸 36个寄存器的空间，可以放下一个trapFrame结构体。
### __alltraps
__alltraps只会保存通用寄存器和部分控制状态寄存器
## 理解上下文切换机制
问题的关键就是解决问题的关键

wjj
问题的关键就是解决问题的
好好学习！！！！
wjj
4
## 理解上下文切换机制
sscratch 寄存器通常用于保存陷阱处理过程中需要临时保存的值。csrw sscratch, sp的作用是将当前堆栈指针保存到 sscratch 寄存器，即保存当前的堆栈状态，确保在陷阱处理完后可以恢复到正常的执行流程。

而csrrw s0, sscratch, x0的作用是将 sscratch 寄存器的值保存到 s0，并将 sscratch 设置为0，sscratch为0意味着其正在进行陷阱处理，若在进行陷阱处理时若再出现陷阱，sscratch为0可以避免出现递归陷阱。

sstatus、sepc、sbadaddr、scause这四个寄存器分别保存当前处理器的状态信息、出现陷阱的指令地址、导致陷阱的错误地址、导致陷阱的原因。保存这些信息是为了在处理陷阱时可以确定导致异常的地址，以及确定陷阱的类型。并且保存下来了进入陷阱处理之前的指令地址以及当时的处理器状态，以便在处理后进行恢复。

所以在进行恢复时我们需要sstatus 和 sepc 两个寄存器的值，以确保处理器能够正确返回到异常发生前的状态。而sbadaddr、scause记录的是陷阱的信息，在陷阱处理后便派不上用场，可以不用恢复。

## 完善异常中断
wjj




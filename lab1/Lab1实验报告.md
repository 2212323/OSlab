# Lab0.5
    为了熟悉使用qemu和gdb进行调试工作,使用gdb调试QEMU模拟的RISC-V计算机加电开始运行到执行应用程序的第一条指令（即跳转到0x80200000）这个阶段的执行过程，说明RISC-V硬件加电后的几条指令在哪里？完成了哪些功能？要求在报告中简要写出练习过程和回答。

在QEMU模拟的riscv计算机里，我们使用QEMU自带的bootloader: OpenSBI固件，那么在 Qemu 开始执行任何指令之前，首先两个文件将被加载到 Qemu 的物理内存中：即作为 bootloader 的 OpenSBI.bin 被加载到物理内存以物理地址 0x80000000 开头的区域上，同时内核镜像 os.bin 被加载到以物理地址 **0x80200000** 开头的区域上

为了正确地和上一阶段的 OpenSBI 对接，我们需要保证内核的第一条指令位于物理地址 0x80200000 处，因为这里的代码是地址相关的，这个地址是由处理器，即Qemu指定的。为此，我们需要将内核镜像预先加载到 Qemu 物理内存以地址 0x80200000 开头的区域上。一旦 CPU 开始执行内核的第一条指令，证明计算机的控制权已经被移交给我们的内核。

# Lab1
##  理解内核启动中的程序入口操作
在 kern/init/entry.S 中，结合操作系统内核启动流程，可以理解以下两条指令：
1. la sp, bootstacktop
la 指令是“加载地址”的缩写（Load Address），用来将某个符号地址加载到寄存器中。在这个指令中：
sp 是栈指针寄存器（Stack Pointer），表示当前栈的顶部。
bootstacktop 是符号，表示内核启动时栈的顶部地址。
这条指令的作用是将内核栈的顶部地址 bootstacktop 加载到栈指针 sp 中。具体步骤是：
内核启动时需要一个专用的栈空间，以便保存函数调用时的局部变量、返回地址等信息。
bootstacktop 定义了内核栈的起始位置，bootstack 是分配的栈空间，大小为 KSTACKSIZE，内存对齐到页大小（PGSHIFT 表示页大小的移位值，通常为 12，即 4KB）。
将栈指针 sp 设置为 bootstacktop 的目的是为内核后续执行准备好栈空间，确保内核代码能够安全地进行栈操作。
2. tail kern_init
tail 指令是一条特殊的跳转指令，它的作用是无条件跳转到目标地址，并且在跳转后不会返回。换句话说，tail 会使得当前的函数（这里是 kern_entry）不会再继续执行后续代码，而是跳转到 kern_init 函数执行，且不会保留返回地址。其效果相当于函数间的“尾调用优化”，减少了栈的开销。
在这个例子中：
tail kern_init 的作用是跳转到 kern_init 函数并开始执行操作系统的初始化过程。
它的目的是启动内核的主要初始化流程，例如设置分页机制、初始化设备、管理内存、加载操作系统内核模块等。
因此，指令 tail kern_init 意味着系统进入内核初始化的关键阶段，并开始执行具体的内核初始化任务。
##  完善中断处理 （需要编程）
+ 代码
szm
## 描述与理解中断流程
    描述ucore中处理中断异常的流程（从异常的产生开始），其中mov a0，sp的目的是什么？
    SAVE_ALL中寄寄存器保存在栈中的位置是什么确定的？对于任何中断，__alltraps 中都需要保存所有寄存器吗？请说明理由。
### 描述中断异常的流程
+ CPU会跳到stvec, stvec直接跳到中断处理程序的入口点,对stvec寄存器做初始化。
+ 保存CPU的寄存器（上下文）到内存中（栈上）
+ 进入trap，把中断处理,异常处理的工作分发给了interrupt_handler()，exception_handler(), 这些函数再根据中断或异常的不同类型来处理。
+ 从内存中（栈上）恢复CPU的寄存器
### `move a0, sp`的目的
**`move a0, sp`**这条指令是将栈指针 `sp` 的值移动到寄存器 `a0` 中。这里 `move` 是一个伪指令，本质上是 `addi a0, sp, 0`，即将 `sp` 的值加上 0，并存入 `a0` 中。通过这一步，栈的地址（`sp` 指向的地址）被存放到了 `a0` 寄存器中，作为参数传递给接下来要调用的函数。通过这一步，栈的地址（`sp` 指向的地址）被存放到了 `a0` 寄存器中，作为参数传递给接下来要调用的函数。
`sp` 寄存器保存了当前栈顶的位置。
保存着当前中断发生时的上下文信息，包括寄存器状态和函数调用栈信息。`trap` 函数需要通过传递的 `sp` 值（栈指针）来获取和处理这些上下文信息。当中断发生时，系统的上下文（寄存器、状态等）通常会被保存到栈中。`trap` 函数需要知道这个栈的位置（由 `sp` 指向）来恢复或进一步处理这些上下文数据。
### SAVE_ALL的位置
`csrw sscratch, sp` 先保存原先的栈顶指针到sscratch，然后在`addi sp, sp, -36 * REGBYTES` 的时候让栈顶指针向低地址空间延伸 36个寄存器的空间，可以放下一个trapFrame结构体。
### __alltraps
__alltraps只会保存通用寄存器和部分控制状态寄存器


在处理任何中断时，__alltraps 函数通常需要保存所有寄存器的状态，以确保在中断处理完成后可以正确恢复到中断前的执行状态。这是因为中断可能会打断当前的执行上下文，寄存器的值可能会被改变。保存所有寄存器（如通用寄存器、程序计数器等）确保在中断返回时，程序能够从中断发生前的状态继续执行。

## 理解上下文切换机制
sscratch 寄存器通常用于保存陷阱处理过程中需要临时保存的值。csrw sscratch, sp的作用是将当前堆栈指针保存到 sscratch 寄存器，即保存当前的堆栈状态，确保在陷阱处理完后可以恢复到正常的执行流程。

而csrrw s0, sscratch, x0的作用是将 sscratch 寄存器的值保存到 s0，并将 sscratch 设置为0，sscratch为0意味着其正在进行陷阱处理，若在进行陷阱处理时若再出现陷阱，sscratch为0可以避免出现递归陷阱。

sstatus、sepc、sbadaddr、scause这四个寄存器分别保存当前处理器的状态信息、出现陷阱的指令地址、导致陷阱的错误地址、导致陷阱的原因。保存这些信息是为了在处理陷阱时可以确定导致异常的地址，以及确定陷阱的类型。并且保存下来了进入陷阱处理之前的指令地址以及当时的处理器状态，以便在处理后进行恢复。

所以在进行恢复时我们需要sstatus 和 sepc 两个寄存器的值，以确保处理器能够正确返回到异常发生前的状态。而sbadaddr、scause记录的是陷阱的信息，在陷阱处理后便派不上用场，可以不用恢复。

## 完善异常中断
wjj




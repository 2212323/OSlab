
## mm_struct和vma_struct的关系

一个 mm_struct 结构体包含多个 vma_struct 结构体。

vma_struct ：vma_struct 代表一个虚拟内存区域（VMA），即一个连续的虚拟地址范围
mm_struct ：mm_struct 代表一个进程的内存管理结构，包含该进程的所有 VMA，代表一个进程的所有虚拟内存区域。

链表结构：mm_struct 使用 mmap_list 字段将所有 vma_struct 结构体链接在一起，形成一个按起始地址排序的链表。每个 vma_struct 通过 list_link 字段链接到链表中。

## 过程

调用vmm_init函数进行虚拟内存管理机制的初始化。在此阶段，主要是建立虚拟地址到物理地址的映射关系，为虚拟内存提供管理支持。

下面我们就来看看如何使用多级页表进行虚拟内存管理和页面置换，ucore在实现上述技术时，需要解决三个关键问题：

当程序运行中访问内存产生page fault异常时，如何判定这个引起异常的虚拟地址内存访问是越界、写只读页的“非法地址”访问还是由于数据被临时换出到磁盘上或还没有分配内存的“合法地址”访问？
何时进行请求调页/页换入换出处理？
如何在现有ucore的基础上实现页替换算法？
接下来将进一步分析完成lab3主要注意的关键问题和涉及的关键数据结构。

## vmm.c文件的作用
文件主要负责虚拟内存管理（VMM）的实现，包括虚拟内存区域（VMA）的管理、页表的操作以及页错误处理等功能

vmm.c 文件是操作系统中虚拟内存管理的核心实现文件。它负责管理进程的虚拟内存区域、处理页表操作、处理页错误异常等。通过这些实现，操作系统能够有效地管理进程的虚拟内存区域，并在需要时快速查找和操作这些区域，从而实现虚拟内存管理和页面置换。

## fs.h
`#define SECTSIZE 512`:定义扇区大小为 512 字节。扇区是磁盘存储的基本单位。

`#define PAGE_NSECT (PGSIZE / SECTSIZE)`:定义每页包含的扇区数。PGSIZE 是页面大小，通常在 mmu.h 中定义。通过将页面大小除以扇区大小，可以得到每页包含的扇区数。

`#define SWAP_DEV_NO 1：`:定义交换设备号为 1。这个宏可能用于标识用于交换的设备。

## 什么是缺页异常？
     
缺页异常是指CPU访问的虚拟地址时， MMU没有办法找到对应的物理地址映射关系，或者与该物理页的访问权不一致而发生的异常。

缺页异常（Page Fault）是指当 CPU 访问一个虚拟地址时，内存管理单元（MMU）无法找到对应的物理地址映射关系，或者与该物理页的访问权限不一致而发生的异常。缺页异常是虚拟内存管理中的一个重要概念，它允许操作系统在需要时动态地将数据从磁盘加载到内存中。

### 缺页异常的原因

1. 页面不存在：虚拟地址对应的页面尚未加载到内存中，可能是因为该页面的数据被换出到磁盘，或者该页面还没有被分配。
2. 访问权限不一致：虚拟地址对应的页面存在，但访问权限不符合要求。例如，尝试写入一个只读页面。
3. 地址越界：访问的虚拟地址超出了进程的地址空间范围。

### 缺页异常的处理过程
当发生缺页异常时，CPU 会触发一个异常处理程序，操作系统通过异常处理程序来处理缺页异常。处理过程通常包括以下步骤：
1. 保存上下文：保存当前的 CPU 寄存器和状态，以便在处理完异常后能够恢复。
2. 查找页面：操作系统查找引起缺页异常的虚拟地址对应的页面。如果页面在磁盘上，则需要将其加载到内存中。
3. 分配页面：如果页面尚未分配，操作系统需要分配一个新的物理页面。
4. 更新页表：将虚拟地址与物理地址的映射关系更新到页表中。
5. 恢复上下文：恢复之前保存的 CPU 寄存器和状态，继续执行被中断的指令。

CPU通过地址总线可以访问连接在地址总线上的所有外设，包括物理内存、IO设备等等，但从CPU发出的访问地址并非是这些外设在地址总线上的物理地址，而是一个虚拟地址，由MMU将虚拟地址转换成物理地址再从地址总线上发出，**MMU上的这种虚拟地址和物理地址的转换关系是需要创建的，并且还需要设置这个物理页的访问权限**。

在实验二中我们有关内存的所有数据结构和相关操作都是直接针对实际存在的资源，即针对物理内存空间的管理，而没有从一般应用程序对内存的“需求”考虑，所以我们需要有相关的数据结构和操作来体现一般应用程序对虚拟内存的“需求”。而一般应用程序的对虚拟内存的“需求”与物理内存空间的“供给”没有直接的对应关系，**在ucore中我们是通过page fault异常处理来间接完成这二者之间
的衔接。**？？？？









## 练习3：给未被映射的地址映射上物理页（需要编程）
*补充完成do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限 的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制 结构所指定的页表，而不是内核的页表。*
*请在实验报告中简要说明你的设计实现过程。请回答如下问题：*
 - *请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。*
 - *如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？*
- *数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？*

函数调用图：trap--> trap_dispatch-->pgfault_handler-->do_pgfault

在trapentry.S中，jal trap，然后trap-->exception_handle-->pgfault_handler-->do_pgfault

### 页目录项（PDE）

**Page Directory Entry 和 Page Table Entry 在哪？？？？？？？？？？？？？**


组成部分：
+ P（Present）：表示该页目录项是否有效。如果为 0，表示该页目录项无效，访问该页会导致页错误。
+ R/W（Read/Write）：表示该页是否可写。如果为 0，表示只读。
+ U/S（User/Supervisor）：表示该页是否可以在用户模式下访问。如果为 0，表示只能在内核模式下访问。
+ 地址：指向页表的物理地址。
  
潜在用处：
+ 页替换：当需要替换一个页时，可以通过 PDE 找到对应的页表，并在页表中找到需要替换的页表项。
+ 权限检查：在页替换过程中，可以通过 PDE 检查页的权限，确保替换后的页具有正确的访问权限，包括页面可读可写的权限检查，以及在何种模式（用户态/内核态）允许进行访问的检查

### 页表项（PTE）
组成部分：
+ P（Present）：表示该页表项是否有效。如果为 0，表示该页表项无效，访问该页会导致页错误。
+ R/W（Read/Write）：表示该页是否可写。如果为 0，表示只读。
+ U/S（User/Supervisor）：表示该页是否可以在用户模式下访问。如果为 0，表示只能在内核模式下访问。
+ 地址：指向物理页的物理地址

潜在用处：
+ 页替换：当需要替换一个页时，可以通过 PTE 找到对应的物理页，并将其换出到磁盘或换入到内存。
+ 权限检查：在页替换过程中，可以通过 PTE 检查页的权限，确保替换后的页具有正确的访问权限。
+ 交换管理：PTE 可以用于标记页是否在交换区中，并在需要时从交换区加载页。？？？？？？？？
  
### 如果 ucore 的缺页服务例程在执行过程中访问内存，出现了页访问异常，硬件要做哪些事情？
当 ucore 的缺页服务例程在执行过程中访问内存，出现了页访问异常时，硬件会执行以下步骤：
1. 保存上下文：硬件会保存当前的 CPU 寄存器和状态，以便在处理完异常后能够恢复。
2. 触发异常处理程序：硬件会触发一个页访问异常处理程序，将控制权交给操作系统。
3. 提供异常信息：
   + CR2 寄存器：硬件会将导致异常的虚拟地址加载到 CR2 寄存器中。
   + 错误代码：硬件会在内核堆栈上提供一个错误代码，描述异常的具体原因。错误代码包括以下信息：
      + P 标志（位 0）：指示异常是由于不存在的页面（0）还是由于访问权限违规或使用保留位（1）。
      + W/R 标志（位 1）：指示导致异常的内存访问是读取（0）还是写入（1）。
      + U/S 标志（位 2）：指示处理器在异常发生时是在用户模式（1）还是在管理模式（0）下执行。

### 数据结构 Page 的全局变量（其实是一个数组）的每一项与页表中的页目录项（PDE）和页表项（PTE）有无对应关系？如果有，其对应关系是啥？
在 ucore 中，Page 结构体的全局变量（数组）用于管理物理内存中的每一个页面。每一个 Page 结构体对应一个物理页。Page 结构体与页表中的页目录项（PDE）和页表项（PTE）有以下对应关系：

+ Page 结构体：
  + struct Page：表示一个物理页，包含物理页的相关信息，如引用计数、物理地址等。
  + 全局变量：Page 结构体的全局变量是一个数组，每一项对应一个物理页。
+ 页表项（PTE）：
  + 物理地址：PTE 中的物理地址字段指向一个物理页。这个物理页在 Page 结构体的全局变量数组中有一个对应的 Page 结构体。
  + 映射关系：PTE 中的物理地址字段与 Page 结构体的物理地址字段相对应。
+ 页目录项（PDE）：
  + **页表地址：PDE 中的地址字段指向一个页表。页表中的每一个 PTE 都指向一个物理页，这些物理页在 Page 结构体的全局变量数组中有对应的 Page 结构体。**

简单来说，PDE中的地址字段-->页表，页表中包含的PTE的物理地址字段-->Page结构体
三者为逐步包含的关系


## 线性地址(la)

### 1. PDX1(la)
- 表示一级页目录索引（Page Directory Index 1）。
- 占用9位，用于选择第一级页目录表中的一个条目。
- 这个索引指向一个二级页目录表。

### 2. PDX0(la)
- 表示二级页目录索引（Page Directory Index 2）。
- 占用9位，用于选择第二级页目录表中的一个条目。
- 这个索引指向最终的页表。

### 3. PTX(la)
- 表示页表索引（Page Table Index）。
- 占用9位，用于选择具体的页表项。
- 这个索引在最终的页表中找到一个具体的物理页框（physical page frame）。

### 4. PGOFF(la)
- 表示页内偏移量（Page Offset）。
- 占用12位，用于指定页面内部的具体字节偏移。
- 当线性地址被映射到物理地址后，这个偏移量直接指向页内的具体位置。

### 地址分解过程
在地址转换过程中，整个线性地址（`la`）被分为这四个部分。通过 `PDX1(la)`、`PDX0(la)` 和 `PTX(la)` 的三级索引，系统逐级从页目录表导航到具体的页表项，最后通过 `PGOFF(la)` 确定页内偏移，从而找到准确的物理地址。

### 例子
假设有一个线性地址：
- `PDX1` 提供了第一级页目录的索引，确定进入哪一个二级页目录。
- `PDX0` 提供了二级页目录的索引，确定进入哪一个最终页表。
- `PTX` 指定了最终页表中的具体条目。
- `PGOFF` 决定了在页内的偏移，最终指向物理内存的一个具体字节。

这些宏帮助分解或组合线性地址，为分页机制中的地址转换提供便利。